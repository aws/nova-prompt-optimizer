# Lightweight Frontend Alternatives for Nova Prompt Optimizer

*Generated by Claude on August 3, 2025*

## Current Stack Complexity

**What you have now:**
```
Frontend: React + TypeScript + Vite + Radix UI + Tailwind + shadcn/ui
Build: Complex webpack/vite build process
Deployment: Docker + Nginx + Docker Compose
Services: Frontend container + Backend + Database + Redis
```

**Complexity issues:**
- Separate frontend build process
- Multiple containers to manage
- Complex dependency management
- Heavy JavaScript bundle
- Over-engineered for the use case

## Recommended Lightweight Alternatives

### üèÜ **Option 1: FastAPI + Static Files + Modern Vanilla JS** (Recommended)

**Why this is perfect for your use case:**
- Single Python process to deploy
- Modern web standards (no framework overhead)
- Maintains all functionality with 90% less complexity
- Perfect for developer/data scientist tools

**Architecture:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FastAPI App   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚Ä¢ API Routes    ‚îÇ
‚îÇ ‚Ä¢ Static Files  ‚îÇ
‚îÇ ‚Ä¢ WebSocket     ‚îÇ
‚îÇ ‚Ä¢ Templates     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Implementation:**

```python
# main.py - Single file deployment
from fastapi import FastAPI, Request, WebSocket
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse

app = FastAPI(title="Nova Prompt Optimizer")

# Serve static files (CSS, JS, images)
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# Serve the main app
@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

# Keep your existing API routes
@app.post("/api/datasets/upload")
async def upload_dataset(file: UploadFile):
    # Your existing logic
    pass

# WebSocket for real-time updates
@app.websocket("/ws/optimization/{optimization_id}")
async def websocket_endpoint(websocket: WebSocket, optimization_id: str):
    # Your existing WebSocket logic
    pass

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**Project Structure:**
```
nova-prompt-optimizer/
‚îú‚îÄ‚îÄ src/amzn_nova_prompt_optimizer/  # Your existing SDK
‚îú‚îÄ‚îÄ web/                             # New simplified web interface
‚îÇ   ‚îú‚îÄ‚îÄ main.py                      # Single FastAPI app
‚îÇ   ‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.html               # Single HTML file
‚îÇ   ‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.css              # Simple CSS
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ js/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ app.js               # Main application logic
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ dataset.js           # Dataset management
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ optimization.js     # Optimization workflow
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ components.js       # Reusable components
‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt             # Minimal dependencies
‚îî‚îÄ‚îÄ deploy.py                        # Simple deployment script
```

**Modern Vanilla JavaScript Example:**
```javascript
// static/js/app.js - Modern ES modules
class NovaOptimizerApp {
    constructor() {
        this.currentView = 'datasets';
        this.init();
    }
    
    init() {
        this.setupNavigation();
        this.setupWebSocket();
        this.loadInitialData();
    }
    
    async uploadDataset(file) {
        const formData = new FormData();
        formData.append('file', file);
        
        try {
            const response = await fetch('/api/datasets/upload', {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) throw new Error('Upload failed');
            
            const result = await response.json();
            this.showNotification('Dataset uploaded successfully', 'success');
            this.refreshDatasetList();
            
        } catch (error) {
            this.showNotification(`Upload failed: ${error.message}`, 'error');
        }
    }
    
    setupWebSocket() {
        // WebSocket for real-time optimization updates
        this.ws = null;
    }
    
    connectToOptimization(optimizationId) {
        this.ws = new WebSocket(`ws://localhost:8000/ws/optimization/${optimizationId}`);
        
        this.ws.onmessage = (event) => {
            const update = JSON.parse(event.data);
            this.updateOptimizationProgress(update);
        };
    }
}

// Initialize app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.app = new NovaOptimizerApp();
});
```

**Simple CSS (no framework needed):**
```css
/* static/css/app.css - Modern CSS Grid/Flexbox */
:root {
    --primary: #2563eb;
    --secondary: #64748b;
    --success: #059669;
    --error: #dc2626;
    --border: #e2e8f0;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
}

.grid {
    display: grid;
    gap: 1rem;
}

.grid-2 { grid-template-columns: repeat(2, 1fr); }
.grid-3 { grid-template-columns: repeat(3, 1fr); }

.card {
    background: white;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.btn {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s;
}

.btn-primary {
    background: var(--primary);
    color: white;
}

.btn-primary:hover {
    background: #1d4ed8;
}

/* Responsive design */
@media (max-width: 768px) {
    .grid-2, .grid-3 { grid-template-columns: 1fr; }
}
```

**Single HTML Template:**
```html
<!-- templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nova Prompt Optimizer</title>
    <link rel="stylesheet" href="/static/css/app.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Nova Prompt Optimizer</h1>
            <nav>
                <button class="btn btn-primary" onclick="app.showView('datasets')">Datasets</button>
                <button class="btn btn-primary" onclick="app.showView('prompts')">Prompts</button>
                <button class="btn btn-primary" onclick="app.showView('optimization')">Optimize</button>
                <button class="btn btn-primary" onclick="app.showView('results')">Results</button>
            </nav>
        </header>
        
        <main id="main-content">
            <!-- Dynamic content loaded here -->
        </main>
    </div>
    
    <script type="module" src="/static/js/app.js"></script>
    <script type="module" src="/static/js/dataset.js"></script>
    <script type="module" src="/static/js/optimization.js"></script>
</body>
</html>
```

**Deployment becomes trivial:**
```python
# deploy.py
import subprocess
import sys
import os

def deploy():
    print("üöÄ Deploying Nova Prompt Optimizer...")
    
    # Install dependencies
    subprocess.run([sys.executable, "-m", "pip", "install", "-r", "web/requirements.txt"])
    
    # Set environment variables
    os.environ.setdefault("DATABASE_URL", "sqlite:///nova_optimizer.db")
    
    # Run the application
    subprocess.run([sys.executable, "web/main.py"])

if __name__ == "__main__":
    deploy()
```

**Benefits:**
- ‚úÖ Single Python file to run
- ‚úÖ No build process needed
- ‚úÖ No Docker complexity
- ‚úÖ Modern JavaScript (ES modules, async/await)
- ‚úÖ Responsive design with pure CSS
- ‚úÖ WebSocket support maintained
- ‚úÖ All functionality preserved
- ‚úÖ 90% reduction in deployment complexity

---

### ü•à **Option 2: Streamlit Integration** (Great for prototyping)

Perfect if you want to focus purely on functionality over custom UI.

```python
# streamlit_app.py
import streamlit as st
import pandas as pd
from amzn_nova_prompt_optimizer import NovaPromptOptimizer

st.set_page_config(page_title="Nova Prompt Optimizer", layout="wide")

st.title("üöÄ Nova Prompt Optimizer")

# Sidebar for navigation
page = st.sidebar.selectbox("Choose a page", ["Dataset Upload", "Prompt Editor", "Optimization", "Results"])

if page == "Dataset Upload":
    st.header("üìä Dataset Management")
    
    uploaded_file = st.file_uploader("Choose a dataset file", type=['csv', 'jsonl'])
    
    if uploaded_file:
        # Process dataset
        df = pd.read_csv(uploaded_file)
        st.write("Dataset Preview:")
        st.dataframe(df.head())
        
        # Column selection
        input_cols = st.multiselect("Select input columns", df.columns)
        output_cols = st.multiselect("Select output columns", df.columns)
        
        if st.button("Process Dataset"):
            # Your dataset processing logic
            st.success("Dataset processed successfully!")

elif page == "Prompt Editor":
    st.header("‚úèÔ∏è Prompt Editor")
    
    system_prompt = st.text_area("System Prompt", height=100)
    user_prompt = st.text_area("User Prompt", height=150)
    
    # Variable detection
    variables = extract_variables(user_prompt)
    if variables:
        st.write("Detected variables:", variables)

elif page == "Optimization":
    st.header("‚ö° Optimization Workflow")
    
    mode = st.selectbox("Optimization Mode", ["micro", "lite", "pro", "premier"])
    
    if st.button("Start Optimization"):
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        # Run optimization with progress updates
        with st.spinner("Optimizing prompt..."):
            # Your optimization logic with progress updates
            for i in range(100):
                progress_bar.progress(i + 1)
                status_text.text(f"Progress: {i+1}%")
                time.sleep(0.1)
        
        st.success("Optimization completed!")

elif page == "Results":
    st.header("üìà Results")
    
    # Display results with charts
    col1, col2 = st.columns(2)
    
    with col1:
        st.metric("Original Score", "0.65", "-0.15")
    
    with col2:
        st.metric("Optimized Score", "0.80", "+0.15")
```

**Deployment:**
```bash
pip install streamlit
streamlit run streamlit_app.py
```

**Benefits:**
- ‚úÖ Zero frontend code needed
- ‚úÖ Built-in components for data science
- ‚úÖ Automatic reactivity
- ‚úÖ Perfect for internal tools
- ‚úÖ Extremely simple deployment

---

### ü•â **Option 3: FastAPI + htmx + Alpine.js** (Server-side focused)

For those who prefer server-side rendering with minimal JavaScript.

```python
# main.py
from fastapi import FastAPI, Request, Form
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse

app = FastAPI()
templates = Jinja2Templates(directory="templates")

@app.get("/", response_class=HTMLResponse)
async def dashboard(request: Request):
    datasets = get_datasets()  # Your logic
    return templates.TemplateResponse("dashboard.html", {
        "request": request,
        "datasets": datasets
    })

@app.post("/upload-dataset")
async def upload_dataset(request: Request, file: UploadFile = File(...)):
    # Process upload
    result = process_dataset(file)
    
    # Return HTML fragment for htmx
    return templates.TemplateResponse("dataset_row.html", {
        "request": request,
        "dataset": result
    })
```

```html
<!-- templates/dashboard.html -->
<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
</head>
<body>
    <div x-data="{ uploading: false }">
        <form hx-post="/upload-dataset" 
              hx-target="#dataset-list" 
              hx-swap="beforeend"
              @htmx:before-request="uploading = true"
              @htmx:after-request="uploading = false">
            
            <input type="file" name="file" required>
            <button type="submit" :disabled="uploading">
                <span x-show="!uploading">Upload</span>
                <span x-show="uploading">Uploading...</span>
            </button>
        </form>
        
        <div id="dataset-list">
            {% for dataset in datasets %}
                {% include "dataset_row.html" %}
            {% endfor %}
        </div>
    </div>
</body>
</html>
```

---

## Migration Strategy

### Phase 1: Simplify Deployment
1. Create the simplified FastAPI app alongside your current setup
2. Copy your existing API routes
3. Create basic HTML/CSS/JS versions of key pages
4. Test functionality parity

### Phase 2: Replace Frontend
1. Implement all features in the new lightweight frontend
2. Add WebSocket support for real-time updates
3. Test thoroughly with your existing backend

### Phase 3: Cleanup
1. Remove Docker complexity
2. Simplify deployment scripts
3. Update documentation

## Comparison

| Feature | Current Stack | Option 1 (Recommended) | Option 2 (Streamlit) | Option 3 (htmx) |
|---------|---------------|------------------------|----------------------|------------------|
| Complexity | Very High | Low | Very Low | Medium |
| Customization | High | High | Low | Medium |
| Performance | Good | Excellent | Good | Good |
| Deployment | Complex | Simple | Very Simple | Simple |
| Maintenance | High | Low | Very Low | Low |
| Learning Curve | High | Low | Very Low | Medium |

## Recommendation

**Go with Option 1 (FastAPI + Static Files + Modern Vanilla JS)** because:

1. **Dramatic simplification**: From 5+ containers to 1 Python process
2. **Maintains functionality**: All features can be preserved
3. **Modern approach**: Uses current web standards, not outdated techniques
4. **Perfect fit**: Ideal for developer/data scientist tools
5. **Easy migration**: Can reuse your existing FastAPI backend
6. **Future-proof**: Easy to enhance or migrate later if needed

This approach will give you 90% of the functionality with 10% of the complexity!
